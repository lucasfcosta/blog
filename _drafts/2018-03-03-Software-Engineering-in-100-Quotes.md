---
layout: post
title: Software Engineering in 100 Quotes
author: Lucas Fernandes da Costa
tags: software engineering quotes 100 management industry
---

I am not good with words. I feel tempted to say most people aren't. But as an engineer and because I know Akin's first law of spacecraft design:

<blockquote>
    Engineering is done with numbers. Analysis without numbers is only an opinion.
    <cite>1st of Akin's Laws of Spacecraft Design</cite>
</blockquote>

I try not to assume things without solid data and facts to back it up.

And, in case you still don't feel comfortable enough to affirm something, Akin has got another law for it:

<blockquote>
    Not having all the information you need is never a satisfactory excuse for not starting the analysis.
    <cite>9th of Akin's Laws of Spacecraft Design</cite>
</blockquote>

Go after the information you need in order to take the right decisions, after all, your efforts to make something faster and better will be futile if you didn't know what your starting point was. Always:

<blockquote>
    Measure. Don't tune for speed until you've measured, and even then don't unless one part of the code overwhelms the rest.
    <cite>Rob Pike's 2nd Law of Programming</cite>
</blockquote>

After all:

<blockquote>
    One accurate measurement is worth a thousand expert opinions.
    <cite>Grace Hopper</cite>
</blockquote>

And

<blockquote>
    You can't manage what you can't measure.
    <cite>Peter Drucker</cite>
</blockquote>

Since we've just mentioned expert opinions I also think it's worth mentioning that we should always pay attention to [appeal to authority fallacies](https://en.wikipedia.org/wiki/Argument_from_authority).

<blockquote>
    The fact that an analysis appears in print has no relationship to the likelihood of its being correct.
    <cite>17th of Akin's Laws of Spacecraft Design</cite>
</blockquote>

And never, ever, forget why you're going after data. You need to be able to know how to extract meaningful information from your measurements, because:

<blockquote>
    The purpose of computing is insight, not numbers.
    <cite>Richard Hamming</cite>
</blockquote>

Once you have measured, make sure you follow the two rules of optimization:

<blockquote>
    Rule 1: Don't do it.
    Rule 2 (for experts only): Don't do it yet.
    <cite>Michael A. Jackson</cite>
</blockquote>

As Donald Knuth once said:

<blockquote>
    Premature optimisation is the root of all evil.
    <cite>Donald Knuth</cite>
</blockquote>

This also reminds me of the [Pareto Principle](https://en.wikipedia.org/wiki/Pareto_principle), which states that:

<blockquote>
    For many events, roughly 80% of the effects come from 20% of the causes
    <cite>Vilfredo Pareto</cite>
</blockquote>

Which is completely true when it comes to computer science, especially due to the fact that:

<blockquote>
    The greatest performance improvement of all is when a system goes from not-working to working.
    <cite>John Ousterhout</cite>
</blockquote>

In computing:

<blockquote>
    More sins are committed in the name of efficiency (without necessarily achieving it) than for any other single reason - including blind stupidity.
    <cite>William A. Wulf</cite>
</blockquote>

Do one thing at a time, that's what TDD is all about and it works really well because:

<blockquote>
    You can't make it better until you make it work.
    <cite>McBryan's Law</cite>
</blockquote>

Usually, especially when it comes to young products, you don't have problems big enough to worry about scale. In those cases, remember Rob Pike:

<blockquote>
    Fancy algorithms are slow when n is small, and n is usually small.
    <cite>Rob Pike's 5th Law of Programming</cite>
</blockquote>

Just focus on building things right. Be elegant, since:

<blockquote>
    The key to performance is elegance, not battalions of special cases.
    <cite>Jon Bentley and Doug McIlroy</cite>
</blockquote>

And:

<blockquote>
    The cleaner and nicer the program, the faster it’s going to run. And if it doesn’t, it’ll be easy to make it fast.
    <cite>Joshua Bloch</cite>
</blockquote>

<blockquote>
    If it doesn’t work, it doesn’t matter how fast it doesn’t work.
    <cite>Mich Ravera</cite>
</blockquote>

<blockquote>
    A program that produces incorrect results twice as fast is infinitely slower.
    <cite>John Osterhout</cite>
</blockquote>

<blockquote>
    Correctness is clearly the prime quality. If a system does not do what it is supposed to do, then everything else about it matters little.
    <cite>Bertrand Meyer</cite>
</blockquote>

And don't even think about mentioning how important it is to have automated tests or lots of clever scripts if they do not add value to what you are building.

<blockquote>
    Automating chaos just gives faster chaos.
    <cite>Mark Fewster</cite>
</blockquote>

You need to know what adds value to what you are building and what does not. Productivity is not about keeping yourself busy.

<blockquote>
    There is nothing more unproductive than to build something efficiently that should not have been built at all.
    <cite>Milt Bryce</cite>
</blockquote>

And it doesn't matter how well you know and applies agile principles and methodologies.

<blockquote>
    Great execution towards a terrible idea will get you nowhere.
    <cite>Sam Altman</cite>
</blockquote>

What you really should do is clearly reflected in YCombinator's motto:

<blockquote>
    Make something people want
    <cite>Paul Graham</cite>
</blockquote>

Computer programs do not exist to please us engineers.

<blockquote>
    The most important property of a program is whether it accomplishes the intention of its user.
    <cite>C.A.R Hoare</cite>
</blockquote>

Be aware of your goal as an engineer.

<blockquote>
    Any run-of-the-mill engineer can design something which is elegant. A good engineer designs systems to be efficient. A great engineer designs them to be effective.
    <cite>36th of Akin's Laws of Spacecraft Design</cite>
</blockquote>

It doesn't matter how clean your code is or how elegant your solutions are if it does not solve anyone's problem.

<blockquote>
    Any program is only as good as it is useful.
    <cite>Linus Torvalds</cite>
</blockquote>

But solving someone's problem isn't enough.

<blockquote>
    In programming, the hard part isn't solving problems, but deciding what problems to solve.
    <cite>Paul Graham</cite>
</blockquote>

Gordon Glegg knows this really well:

<blockquote>
    Sometimes the problem is to discover what the problem is.
    <cite>Gordon Glegg</cite>
</blockquote>

And maybe someone has already discovered what the problem is, but their timing was not right or their team was not ready. In any case, you've got lessons to learn from them.

<blockquote>
    Learn from the mistakes of others. You can't live long enough to make them all yourself.
    <cite>Eleanor Roosevelt</cite>
</blockquote>

 You don't need need to worry so much about being the first one to do something. You also don't need to be *that* disruptive. Most businesses are not and they still succeed.

<blockquote>
    A good way to have good ideas is by being unoriginal.
    <cite>Bram Cohen</cite>
</blockquote>

<blockquote>
    People think that computer science is the art of geniuses but the actual reality is the opposite, just many people doing things that build on each other, like a wall of mini stones. 
    <cite>Donald Knuth</cite>
</blockquote>

Please:

<blockquote>
    Don't reinvent the wheel, just realign it.
    <cite>Anthony J. D'Angelo</cite>
</blockquote>

Software only exists to either decrease costs, increase revenue, or both. Like it or not:

<blockquote>
    Software solves business problems.
    <cite>Patrick Mckenzie</cite>
</blockquote>

In the end:

<blockquote>
    It is not about bits, bytes and protocols, but profits, losses and margins.
    <cite>Lou Gerstner</cite>
</blockquote>

It sounds sad, but as Patrick McKenzie and Douglas McIlroy noticed:

<blockquote>
    You’re in the business of unemploying people.
    <cite>Patrick McKenzie</cite>
</blockquote>

<blockquote>
    As a programmer, it is your job to put yourself out of business. What you do today can be automated tomorrow.
    <cite>Doug McIlroy</cite>
</blockquote>

And then, only then, when you know which problem you're going to solve it's time to decide **how** it is going to be solved. In order to do that, we all know that we must have specs, but in reality:

<blockquote>
    Writing specs is like flossing: everybody agrees that it's a good thing, but nobody does it.
    <cite>Joel Spolsky</cite>
</blockquote>

All of us need to be aware that:

<blockquote>
    Without requirements or design, programming is the art of adding bugs to an empty text file.
    <cite>Louis Srygley</cite>
</blockquote>

And even if we do write specs, most of the time we're trying to hit a moving target.

<blockquote>
    Walking on water and developing software from a specification are easy if both are frozen.
    <cite>Edward V. Berard</cite>
</blockquote>

<blockquote>
    In software, we rarely have meaningful requirements. Even if we do, the only measure of success that matters is whether our solution solves the customer’s shifting idea of what their problem is.
    <cite>Jeff Atwood</cite>
</blockquote>

Building software is not only about code.

<blockquote>
    Much of the essence of building a program is, in fact, the debugging of the specification.
    <cite>Fred Brooks</cite>
</blockquote>

So when it comes to debugging the specification, anyone who has been working in this industry for long enough knows that talking to your customers isn't enough most of the time.

<blockquote>
    If we’d asked the customers what they wanted, they would have said “faster horses”
    <cite>Henry Ford</cite>
</blockquote>

Well written specs are key, not only for building the right product, but also to allow engineers to build it efficiently. If you ever had to write code for a feature which didn't have specs that were clear enough, you know what I'm talking about.

<blockquote>
    Good specifications will always improve programmer productivity far better than any programming tool or technique.
    <cite>Milt Bryc</cite>
</blockquote>

But managers and product people need to know what to prioritize and how to calculate costs.

<blockquote>
    The cost of adding a feature isn’t just the time it takes to code it. The cost also includes the addition of an obstacle to future expansion. The trick is to pick the features that don’t fight each other.
    <cite>John Carmack</cite>
</blockquote>

Nowadays,

<blockquote>
    We see a lot of feature-driven product design in which the cost of features is not properly accounted. Features can have a negative value to customers because they make the products more difficult to understand and use. We are finding that people like products that just work. It turns out that designs that just work are much harder to produce that designs that assemble long lists of features.
    <cite>Douglas Crockford</cite>
</blockquote>

<blockquote>
    Any program that tries to be so generalized and configurable that it could handle any kind of task will either fall short of this goal, or will be horribly broken.
    <cite>Chris Wenham</cite>
</blockquote>

Having said that, I think we all agree that, when it comes to features:

<blockquote>
    The whole point of getting things done is knowing what to leave undone.
    <cite>Oswald Chambers</cite>
</blockquote>

And the only way of knowing what to leave undone is having a clear mission, is being purpose-driven. [Purpose-driven companies are often more successful](https://www.fastcompany.com/3048197/why-purpose-driven-companies-are-often-more-successful) due to the fact that:

<blockquote>
    The most important single aspect of software development is to be clear about what you are trying to build.
    <cite>Bjarne Stroustrup</cite>
</blockquote>

What I'm trying to say here is that the more important part of writing software is asking the right questions. I think this is why this anecdote by one of my favorite characters in history, [Charles Babbage](https://en.wikipedia.org/wiki/Charles_Babbage), fits well in this context:

<blockquote>
    "On two occasions I have been asked [by members of Parliament]: 'Pray, Mr. Babbage, if you put into the machine wrong figures, will the right answers come out?' I am not able rightly to apprehend the kind of confusion of ideas that could provoke such a question."
    <cite>Charles Babbage</cite>
</blockquote>

Of course:

<blockquote>
    You certainly don’t need to have everything figured out in the path from here to world domination.
    <cite>Sam Altman</cite>
</blockquote>

So:

<blockquote>
    Do what you can, where you are, with what you have.
    <cite>Roosevelt's Law of Task Planning</cite>
</blockquote>

Because:

<blockquote>
    If it is not written down, it does not exist.
    <cite>Philippe Kruchten</cite>
</blockquote>

As we have mentioned before:

<blockquote>
    Learn not to add too many features right away, and get the core idea built and tested.
    <cite>Leah Culver</cite>
</blockquote>

It doesn't matter how many unit, integration or acceptance tests you've got.

<blockquote>
    Regardless of your plans, production is the ultimate testing environment.
    <cite>JT Wall</cite>
</blockquote>

<blockquote>
    Computer science education cannot make anybody an expert programmer any more than studying brushes and pigment can make somebody an expert painter.
    <cite>Eric S. Raymond</cite>
</blockquote>

So you need to get your hands dirty.

<blockquote>
    As a rule, software systems do not work well until they have been used, and have failed repeatedly, in real applications.
    <cite>Dave Parnas</cite>
</blockquote>

And they **will** eventually fail.

<blockquote>
    No one in the brief history of computing has ever written a piece of perfect software. It's unlikely that you'll be the first.
    <cite>Andy Hunt</cite>
</blockquote>

So let's go back to Akin's laws of Spacecraft design because they teach us an important lesson:

<blockquote>
    To design a spacecraft right takes an infinite amount of effort. This is why it's a good idea to design them to operate when some things are wrong.
    <cite>2nd of Akin's Laws of Spacecraft Design</cite>
</blockquote>

Even if the odds are small, they still exist.

<blockquote>
    That hardly ever happens is another way of saying 'it happens'.
    <cite>Douglas Crockford</cite>
</blockquote>

Experienced engineers know that when writing software:

<blockquote>
    Making code do what it's supposed to do is the easy part. Handling the myriad ways it can go wrong is the real work. 
    <cite>@ajlozier</cite>
</blockquote>

So why not avoid writing code as much as possible?

When it comes to security:

<blockquote>
    The most secure code in the world is code which is never written.
    <cite>Colin Percival</cite>
</blockquote>

When it comes to beauty:

<blockquote>
    The most beautiful code, the most beautiful functions, and the most beautiful programs are sometimes not there at all.
    <cite>Jon Bentley</cite>
</blockquote>

And when it comes to costs, efficiency, and reliability:

<blockquote>
    The cheapest, fastest and most reliable components of a computer system are those that aren’t there.
    <cite>Gordon Bell</cite>
</blockquote>

Work to not work. Strive to be lazy.

<blockquote>
    The code you write makes you a programmer. The code you delete makes you a good one. The code you don't have to write makes you a great one.
    <cite>Mario Fusco</cite>
</blockquote>

Looking at a PR and noticing that you've got a huge number of additions, many times, is not a good thing. The more code you delete, the better.

<blockquote>
    Deleted code is debugged code.
    <cite>Jeff Sickel</cite>
</blockquote>

<blockquote>
    When debugging, novices insert corrective code; experts remove defective code.
    <cite>Richard Pattis</cite>
</blockquote>

And Ken Thompson, the man himself, completely agrees with it.

<blockquote>
    One of my most productive days was throwing away 1000 lines of code.
    <cite>Ken Thompson</cite>
</blockquote>

Given all this, we can conclude that:

<blockquote>
    The real hero of programming is the one who writes negative code.
    <cite>Douglas McIlroy</cite>
</blockquote>

The less code you have, the more sophisticated you are. Da Vinci knew that way before we had any computers:

<blockquote>
    Simplicity is the ultimate sophistication.
    <cite>Leonardo da Vinci</cite>
</blockquote>

Antoine de Saint-Exupéry also had something very wise to say about simplicity:

<blockquote>
    A designer knows that he has achieved perfection not when there is nothing left to add, but when there is nothing left to take away.
    <cite>de Saint-Exupery's Law of Design</cite>
</blockquote>

And it's important to keep this in mind because:

<blockquote>
    Simplicity is prerequisite for reliability.
    <cite>Edsger W. Dijkstra</cite>
</blockquote>

I know we have already talked a lot about the importance of being picky when deciding which features to implement, but one cannot emphasize that enough, especially given the huge impact it has on complexity.

<blockquote>
    A primary cause of complexity is that software vendors uncritically adopt almost any feature that users want.
    <cite>Niklaus Wirth</cite>
</blockquote>

Follow the UNIX philosophy and focus on doing one thing and doing it well.

<blockquote>
    So much complexity in software comes from trying to make one thing do two things.
    <cite>Ryan Singer</cite>
</blockquote>

Avoid it at all costs.

<blockquote>
    The purpose of software engineering is to control complexity, not to create it.
    <cite>Pamela Zave</cite>
</blockquote>

Even if you find a complex system that you admire, remember this:

<blockquote>
    A complex system that works is invariably found to have evolved from a simple system that worked. The inverse proposition also appears to be true: A complex system designed from scratch never works and cannot be made to work.
    <cite>John Gall</cite>
</blockquote>

<blockquote>
    Inside every well-written large program is a well-written small program.
    <cite>C.A.R Hoare</cite>
</blockquote>

Complexity not only makes it harder to investigate bugs and fix them, it affects all the human components involved in the project.

<blockquote>
    Complexity kills. It sucks the life out of developers, it makes products difficult to plan, build and test, it introduces security challenges, and it causes end-user and administrator frustration.
    <cite>Ray Ozzie</cite>
</blockquote>

In any software, the ones that build it are as important as the project itself so make sure everyone is satisfied with what they are doing.

<blockquote>
    Programmers don't burn out on hard work, they burn out on change-with-the-wind directives and not 'shipping'.
    <cite>Mark Berry</cite>
</blockquote>

But talking isn't enough, you've gotta fight technical debt actively.

<blockquote>
    An evolving system increases its complexity unless work is done to reduce it.
    <cite>Meir Lehman</cite>
</blockquote>

Even if in the beginning you feel like fighting technical debt is not something your customers will notice, you will soon realize that:

<blockquote>
    Good design adds value faster than it adds cost.
    <cite>Thomas C. Gale</cite>
</blockquote>

In fact, even technical skills are not enough when it comes to design, after all:

<blockquote>
    A bad design with a good presentation is doomed eventually. A good design with a bad presentation is doomed immediately.
    <cite>20th of Akin's Laws of Spacecraft Design</cite>
</blockquote>

And that:

<blockquote>
    No matter how slow you are writing clean code, you will always be slower if you make a mess.
    <cite>Uncle Bob Martin</cite>
</blockquote>

Know when to walk away.

<blockquote>
    Sometimes it pays to stay in bed on Monday, rather than spending the rest of the week debugging Monday's code.
    <cite>Christopher Thompson</cite>
</blockquote>

And know when you are not ready to write code. Don't be afraid of getting a piece of paper and drafting your idea before starting to type.

<blockquote>
    First, solve the problem. Then, write the code.
    <cite>John Johnson</cite>
</blockquote>

Because:

<blockquote>
    The sooner you start to code, the longer the program will take.
    <cite>Roy Carlson</cite>
</blockquote>

<blockquote>
    Weeks of coding can save you hours of planning.
    <cite>Unknown</cite>
</blockquote>

Even if you planned and solved the problem first, it is likely that your estimate will be wrong many times. When estimating, keep Hofstadter's Law in mind:

<blockquote>
    Hofstadter’s Law: It always takes longer than you expect, even when you take into account Hofstadter’s Law.
    <cite>Douglas Hofstadter</cite>
</blockquote>

Good engineers are careful. They try to make sure they have considered all details and asked all the necessary questions. When doing whiteboard exercises on interviews, one of the things that interviewers take into account is your ability to figure out which pieces of the puzzle are missing. They value it so much because:

<blockquote>
    A good programmer is someone who always looks both ways before crossing a one-way street.
    <cite>Doug Linder</cite>
</blockquote>

If you're solving a kind of problem you have never solved before then you need to be even more careful and when that happens you will probably suffer from [impostor syndrome](https://en.wikipedia.org/wiki/Impostor_syndrome), but that's okay too.

<blockquote>
    Every great developer you know got there by solving problems they were unqualified to solve until they actually did it.
    <cite>Patrick McKenzie</cite>
</blockquote>

In software engineering and life in general:

<blockquote>
    The true test of intelligence is not how much we know how to do, but how to behave when we don’t know what to do.
    <cite>John Holt</cite>
</blockquote>

Learn when to ask why and trust determinism, [it's ~~almost~~ always your fault, never the compiler's](https://blog.codinghorror.com/the-first-rule-of-programming-its-always-your-fault/).

<blockquote>
    The amateur software engineer is always in search of magic.
    <cite>Grady Booch</cite>
</blockquote>

Sometimes it seems hard to believe in that, but only because:

<blockquote>
    Any sufficiently advanced technology is indistinguishable from magic.
    <cite>Clarke's Third Law</cite>
</blockquote>

If I could use a single quote for whenever people ask me for career advice, I would say the same thing as Paul Graham:

<blockquote>
    One, learn a lot about things that matter. Two, work on problems that interest you and three, with people you like and respect.
    <cite>Paul Graham</cite>
</blockquote>

Develop soft skills, focus on things that matter.

<blockquote>
    Programming is not a zero-sum game. Teaching something to a fellow programmer doesn’t take it away from you.
    <cite>John Karmack</cite>
</blockquote>

<blockquote>
    Be gentle, kind, and forgiving of your peers; respect from people you respect is really the only reward that sticks.
    <cite>Rusty Russell</cite>
</blockquote>

If you are managing people, that becomes even more important.

<blockquote>
    There's one technique that you must use if you want people to listen to you: listen to them.
    <cite>The Pragmatic Programmer</cite>
</blockquote>

Just because you are a leader, it doesn't matter you will always be right.

<blockquote>
    The group is often much wiser than the individual, and I've been proven wrong more than once!
    <cite>Sam Newman</cite>
</blockquote>

Listen to everyone. Always seek consensus.

<blockquote>
    In nature, the optimum is almost always in the middle somewhere. Distrust assertions that the optimum is at an extreme point.
    <cite>8th of Akin's Laws of Spacecraft Design</cite>
</blockquote>

And please:

<blockquote>
    Be humble, communicate clearly, and respect others. It costs nothing to be kind, but the impact is priceless.
    <cite>Addy Osmani</cite>
</blockquote>

If you were not able to convince your team, learn when it's the right time to intervene.

<blockquote>
    Think about teaching a child to ride a bike. You can't ride it for them. You watch them wobble, but if you stepped in every time it looked like they might fall off, then they would never learn, and, in any case, they fall off far less than you think they will! But if you see them about to veer into traffic, or into a nearby duck pond, then you have to step in.
    <cite>Sam Newman</cite>
</blockquote>

And now, after 100 quotes about software engineering, I'll allow myself to add an extra one, that pretty much sums it all up.

<blockquote>
    If it takes more than a sentence to explain what you are doing, it’s almost always a sign that what you are doing is too complicated.
    <cite>Sam Altman</cite>
</blockquote>

**Yes, Sam, what we are doing __is__, indeed, very complicated**.

<br>

## **Get in touch!**

If you disagree with anything I said or if you have anything you'd like to add or comment, feel free to use the space below or send me a tweet [@lfernandescosta](https://twitter.com/lfernandescosta).

If you feel like submitting a PR to fix any possible typos or fix my grammar mistakes, you can also find me [on GitHub @lucasfcosta](https://github.com/lucasfcosta).

<br>

## **More Amazing Quotes**

The quotes in this post come from many different places. I can't link all of them because I usually just add them to my Evernote when I find one that I like, but you can find lots of them at:

* [@CodeWisdom](https://twitter.com/codewisdom) on Twitter - Highly recommended, amazing quotes every day!
* [58 Quotes from Sam Altman on Startup Ideas](https://medium.com/how-to-start-a-startup/58-quotes-from-sam-altman-on-startup-ideas-e3582361cd4f)
* [50 Quotes from Paul Graham on Counterintuitive Parts of Startups, and How to Have Ideas](https://medium.com/how-to-start-a-startup/50-quotes-from-paul-graham-on-counterintuitive-parts-of-startups-and-how-to-have-ideas-4209154ff319)
* [http://www.linfo.org/q_programming.html](http://www.linfo.org/q_programming.html)

Thanks for reading!
